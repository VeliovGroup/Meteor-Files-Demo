{"version":3,"sources":["meteor://ðŸ’»app/packages/mrt_filesize/packages/mrt_filesize.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/mrt_filesize.js","sourcesContent":["(function () {\n\n///////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                       //\n// packages/mrt:filesize/filesize.js                                                     //\n//                                                                                       //\n///////////////////////////////////////////////////////////////////////////////////////////\n                                                                                         //\n/**                                                                                      // 1\n * filesize                                                                              // 2\n *                                                                                       // 3\n * @author Jason Mulligan <jason.mulligan@avoidwork.com>                                 // 4\n * @copyright 2014 Jason Mulligan                                                        // 5\n * @license BSD-3 <https://raw.github.com/avoidwork/filesize.js/master/LICENSE>          // 6\n * @link http://filesizejs.com                                                           // 7\n * @module filesize                                                                      // 8\n * @version 2.0.3                                                                        // 9\n */                                                                                      // 10\n                                                                                         // 11\nvar bit   = /b$/,                                                                        // 12\n    radix = 10,                                                                          // 13\n    left  = /.*\\./,                                                                      // 14\n    zero  = /^0$/;                                                                       // 15\n/**                                                                                      // 16\n * SI suffixes                                                                           // 17\n *                                                                                       // 18\n * @type {Object}                                                                        // 19\n */                                                                                      // 20\nvar si = {                                                                               // 21\n\tbits  : [\"B\", \"kb\", \"Mb\", \"Gb\", \"Tb\", \"Pb\", \"Eb\", \"Zb\", \"Yb\"],                          // 22\n\tbytes : [\"B\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"]                           // 23\n};                                                                                       // 24\n                                                                                         // 25\n/**                                                                                      // 26\n * filesize                                                                              // 27\n *                                                                                       // 28\n * @method filesize                                                                      // 29\n * @param  {Mixed}   arg        String, Int or Float to transform                        // 30\n * @param  {Object}  descriptor [Optional] Flags                                         // 31\n * @return {String}             Readable file size String                                // 32\n */                                                                                      // 33\nfilesize = function ( arg, descriptor ) {                                                // 34\n\tvar result = \"\",                                                                        // 35\n\t    skip   = false,                                                                     // 36\n\t    e, base, bits, ceil, neg, num, round, unix, spacer, suffix, z, suffixes;            // 37\n                                                                                         // 38\n\tif ( isNaN( arg ) ) {                                                                   // 39\n\t\tthrow new Error( \"Invalid arguments\" );                                                // 40\n\t}                                                                                       // 41\n                                                                                         // 42\n\tdescriptor = descriptor || {};                                                          // 43\n\tbits       = ( descriptor.bits === true );                                              // 44\n\tunix       = ( descriptor.unix === true );                                              // 45\n\tbase       = descriptor.base     !== undefined ? descriptor.base     : unix ? 2  : 10;  // 46\n\tround      = descriptor.round    !== undefined ? descriptor.round    : unix ? 1  : 2;   // 47\n\tspacer     = descriptor.spacer   !== undefined ? descriptor.spacer   : unix ? \"\" : \" \"; // 48\n\tsuffixes   = descriptor.suffixes !== undefined ? descriptor.suffixes : {};              // 49\n\tnum        = Number( arg );                                                             // 50\n\tneg        = ( num < 0 );                                                               // 51\n\tceil       = base > 2 ? 1000 : 1024;                                                    // 52\n                                                                                         // 53\n\t// Flipping a negative number to determine the size                                     // 54\n\tif ( neg ) {                                                                            // 55\n\t\tnum = -num;                                                                            // 56\n\t}                                                                                       // 57\n                                                                                         // 58\n\t// Zero is now a special case because bytes divide by 1                                 // 59\n\tif ( num === 0 ) {                                                                      // 60\n\t\tif ( unix ) {                                                                          // 61\n\t\t\tresult = \"0\";                                                                         // 62\n\t\t}                                                                                      // 63\n\t\telse {                                                                                 // 64\n\t\t\tsuffix = \"B\";                                                                         // 65\n\t\t\tresult = \"0\" + spacer + ( suffixes[suffix] || suffix );                               // 66\n\t\t}                                                                                      // 67\n\t}                                                                                       // 68\n\telse {                                                                                  // 69\n\t\te = Math.floor( Math.log( num ) / Math.log( 1000 ) );                                  // 70\n                                                                                         // 71\n\t\t// Exceeding supported length, time to reduce & multiply                               // 72\n\t\tif ( e > 8 ) {                                                                         // 73\n\t\t\tresult = result * ( 1000 * ( e - 8 ) );                                               // 74\n\t\t\te      = 8;                                                                           // 75\n\t\t}                                                                                      // 76\n                                                                                         // 77\n\t\tif ( base === 2 ) {                                                                    // 78\n\t\t\tresult = num / Math.pow( 2, ( e * 10 ) );                                             // 79\n\t\t}                                                                                      // 80\n\t\telse {                                                                                 // 81\n\t\t\tresult = num / Math.pow( 1000, e );                                                   // 82\n\t\t}                                                                                      // 83\n                                                                                         // 84\n\t\tif ( bits ) {                                                                          // 85\n\t\t\tresult = ( result * 8 );                                                              // 86\n                                                                                         // 87\n\t\t\tif ( result > ceil ) {                                                                // 88\n\t\t\t\tresult = result / ceil;                                                              // 89\n\t\t\t\te++;                                                                                 // 90\n\t\t\t}                                                                                     // 91\n\t\t}                                                                                      // 92\n                                                                                         // 93\n\t\tresult = result.toFixed( e > 0 ? round : 0 );                                          // 94\n\t\tsuffix = si[bits ? \"bits\" : \"bytes\"][e];                                               // 95\n                                                                                         // 96\n\t\tif ( !skip && unix ) {                                                                 // 97\n\t\t\tif ( bits && bit.test( suffix ) ) {                                                   // 98\n\t\t\t\tsuffix = suffix.toLowerCase();                                                       // 99\n\t\t\t}                                                                                     // 100\n                                                                                         // 101\n\t\t\tsuffix = suffix.charAt( 0 );                                                          // 102\n\t\t\tz      = result.replace( left, \"\" );                                                  // 103\n                                                                                         // 104\n\t\t\tif ( suffix === \"B\" ) {                                                               // 105\n\t\t\t\tsuffix = \"\";                                                                         // 106\n\t\t\t}                                                                                     // 107\n\t\t\telse if ( !bits && suffix === \"k\" ) {                                                 // 108\n\t\t\t\tsuffix = \"K\";                                                                        // 109\n\t\t\t}                                                                                     // 110\n                                                                                         // 111\n\t\t\tif ( zero.test( z ) ) {                                                               // 112\n\t\t\t\tresult = parseInt( result, radix );                                                  // 113\n\t\t\t}                                                                                     // 114\n                                                                                         // 115\n\t\t\tresult += spacer + ( suffixes[suffix] || suffix );                                    // 116\n\t\t}                                                                                      // 117\n\t\telse if ( !unix ) {                                                                    // 118\n\t\t\tresult += spacer + ( suffixes[suffix] || suffix );                                    // 119\n\t\t}                                                                                      // 120\n\t}                                                                                       // 121\n                                                                                         // 122\n\t// Decorating a 'diff'                                                                  // 123\n\tif ( neg ) {                                                                            // 124\n\t\tresult = \"-\" + result;                                                                 // 125\n\t}                                                                                       // 126\n                                                                                         // 127\n\treturn result;                                                                          // 128\n}                                                                                        // 129\n                                                                                         // 130\n                                                                                         // 131\n// // CommonJS, AMD, script tag                                                          // 132\n// if ( typeof exports !== \"undefined\" ) {                                               // 133\n// \tmodule.exports = filesize;                                                           // 134\n// }                                                                                     // 135\n// else if ( typeof define === \"function\" ) {                                            // 136\n// \tdefine( function () {                                                                // 137\n// \t\treturn filesize;                                                                    // 138\n// \t} );                                                                                 // 139\n// }                                                                                     // 140\n// else {                                                                                // 141\n// \tglobal.filesize = filesize;                                                          // 142\n// }                                                                                     // 143\n                                                                                         // 144\n                                                                                         // 145\n///////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}