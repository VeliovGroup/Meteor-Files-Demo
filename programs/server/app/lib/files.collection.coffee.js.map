{"version":3,"sources":["meteor://ðŸ’»app/lib/files.collection.coffee"],"names":[],"mappings":";;;;;;;;;AAYA,WAAW,CAAC,KAAZ,GAAwB,oBACtB;AAAA,SAAkB,KAAlB;AAAA,EACA,UAAkB,KADlB;AAAA,EAEA,WAAkB,OAAK,IAFvB;AAAA,EAGA,aAAkB,kCAHlB;AAAA,EAIA,gBAAkB,eAJlB;AAAA,EAKA,iBAAkB,KALlB;AAAA,EAMA,gBAAkB;AAAG,QAAG,IAAC,KAAI,CAAC,IAAN,IAAc,OAAO,IAAP,GAAc,GAA/B;aAAwC,KAAxC;KAAA;aAAkD,oDAAiD,CAAC,SAAS,IAAC,KAAI,CAAC,IAAf,CAAD,EAAnG;KAAH;EAAA,CANlB;AAAA,EAOA,kBAAkB,SAAC,OAAD;AAChB;AAAA,0CAAU,CAAE,KAAK,CAAC,kBAAf,KAA2B,MAA9B;AACE,iBAAW,CAAC,KAAK,CAAC,UAAU,CAAC,MAA7B,CAAoC,OAAO,CAAC,GAA5C,EAAiD;AAAA,cAAM;AAAA,4BAAkB,CAAlB;SAAN;OAAjD,EADF;KAAA;AAEA,WAAO,IAAP,CAHgB;EAAA,CAPlB;CADsB,CAAxB;;AA8CA,IAAG,MAAM,CAAC,QAAV;AACE,aAAW,CAAC,KAAK,CAAC,UAAlB;AAAA,EACA,WAAW,CAAC,KAAK,CAAC,UAAU,CAAC,YAA7B,CAA0C,WAAW,CAAC,KAAK,CAAC,MAA5D,CADA;AAAA,EAEA,WAAW,CAAC,KAAK,CAAC,UAAU,CAAC,YAA7B,CAA0C;AAAA,IAAC,iBAAiB,CAAlB;GAA1C,EAAgE;AAAA,IAAC,oBAAoB,CAArB;AAAA,IAAwB,YAAY,IAApC;GAAhE,CAFA;AAAA,EAwBA,MAAM,CAAC,WAAP,CAAmB;WACjB,WAAW,CAAC,KAAK,CAAC,MAAlB,CAAyB;AAAA,uBAAiB;AAAA,cAAU,SAAK,CAAC,EAAC,SAAF,IAAc,MAAnB,CAAV;OAAjB;KAAzB,EADiB;EAAA,CAAnB,EAGE,MAHF,CAxBA;AAAA,EA6BA,MAAM,CAAC,OAAP,CAAe,QAAf,EAAyB,SAAC,IAAD;;MAAC,OAAO;KAC/B;AAAA,UAAM,IAAN,EAAY,MAAZ;WACA,WAAW,CAAC,KAAK,CAAC,UAAU,CAAC,IAA7B,CAAkC,EAAlC,EAEE;AAAA,aAAO,IAAP;AAAA,MACA,MAAM;AAAA,2BAAmB,EAAnB;OADN;AAAA,MAEA,QACE;AAAA,aAAK,CAAL;AAAA,QACA,MAAM,CADN;AAAA,QAEA,MAAM,CAFN;AAAA,QAGA,MAAM,CAHN;AAAA,QAIA,SAAS,CAJT;AAAA,QAKA,SAAS,CALT;AAAA,QAMA,SAAS,CANT;AAAA,QAOA,QAAQ,CAPR;AAAA,QAQA,WAAW,CARX;OAHF;KAFF,EAFuB;EAAA,CAAzB,CA7BA;AAAA,EA8CA,MAAM,CAAC,OAAP,CAAe,MAAf,EAAuB,SAAC,GAAD;AACrB,UAAM,GAAN,EAAW,MAAX;WACA,WAAW,CAAC,KAAK,CAAC,UAAU,CAAC,IAA7B,CAAkC,GAAlC,EAFqB;EAAA,CAAvB,CA9CA;AAAA,EAkDA,MAAM,CAAC,OAAP,CACE;AAAA,mBAAe;aAAG,WAAW,CAAC,KAAK,CAAC,UAAU,CAAC,IAA7B,CAAkC,EAAlC,CAAqC,CAAC,KAAtC,GAAH;IAAA,CAAf;GADF,CAlDA,CADF;CA9CA","file":"/lib/files.collection.coffee.js","sourcesContent":["# Uncomment for DropBox usage\n# Read: https://github.com/VeliovGroup/Meteor-Files/wiki/Third-party-storage\n# if Meteor.isServer\n#   Dropbox = Npm.require 'dropbox'\n#   fs      = Npm.require 'fs'\n#   bound   = Meteor.bindEnvironment (callback) -> return callback()\n#   client  = new (Dropbox.Client)({\n#     key: 'XXX'\n#     secret: 'XXX'\n#     token: 'XXXXXXXXX'\n#   })\n\nCollections.files = new FilesCollection\n  debug:            false\n  throttle:         false\n  chunkSize:        1024*1024\n  storagePath:      'assets/app/uploads/uploadedFiles'\n  collectionName:   'uploadedFiles'\n  allowClientCode:  false\n  onBeforeUpload:   -> if @file.size <= 1024 * 1024 * 128 then true else \"Max. file size is 128MB you've tried to upload #{filesize(@file.size)}\"\n  downloadCallback: (fileObj) -> \n    if @params?.query.download is 'true'\n      Collections.files.collection.update fileObj._id, $inc: 'meta.downloads': 1\n    return true\n  # Uncomment for DropBox usage\n  # onAfterUpload:    (fileRef) ->\n  #   self = @\n  #   fs.readFile fileRef.path, (error, data) -> bound ->\n  #     if error\n  #       console.error error\n  #     else\n  #       # Write file to DropBox\n  #       client.writeFile \"#{fileRef._id}.#{fileRef.extension}\", data, (error, stat) -> bound ->\n  #         if error\n  #           console.error error\n  #         else\n  #           # Generate downloadable link\n  #           client.makeUrl stat.path, {long: true, downloadHack: true}, (error, xml) -> bound ->\n  #             # Store downloadable in file's meta object\n  #             self.collection.update {_id: fileRef._id}, {$set: {'meta.pipeFrom': xml.url, 'meta.pipePath': stat.path}}, (error) ->\n  #               if error\n  #                 console.error error\n  #               else\n  #                 # Remove file from FS\n  #                 self.unlink fileRef\n  # interceptDownload: (http, fileRef) ->\n  #   path = fileRef?.meta?.pipeFrom\n  #   if path\n  #     # If file is moved to DropBox\n  #     # We will redirect browser to DropBox\n  #     http.response.writeHead 302, 'Location': path\n  #     http.response.end()\n  #     return true\n  #   else\n  #     # While file is not uploaded to DropBox\n  #     # We will serve file from FS\n  #     return false\n\nif Meteor.isServer\n  Collections.files.denyClient()\n  Collections.files.collection.attachSchema Collections.files.schema\n  Collections.files.collection._ensureIndex {'meta.expireAt': 1}, {expireAfterSeconds: 0, background: true}\n\n  # Uncomment for DropBox usage\n  # Intercept File's collection remove method\n  # to remove file from DropBox\n  # _origRemove = Collections.files.remove\n  # Collections.files.remove = (search) ->\n  #   cursor = @collection.find search\n  #   cursor.forEach (fileRef) ->\n  #     if fileRef?.meta?.pipePath\n  #       client.remove fileRef.meta.pipePath, (error) ->\n  #         if error\n  #           console.error error\n  #   # Call original method\n  #   _origRemove.call @, search\n\n  # Remove all files on server load/reload, useful while testing/development\n  # Meteor.startup -> Collections.files.remove {}\n\n  # Remove files along with MongoDB records two minutes before expiration date\n  # Although we have 'expireAfterSeconds' index on 'meta.expireAt' field,\n  # it won't remove files themselves.\n  Meteor.setInterval ->\n    Collections.files.remove 'meta.expireAt': $lte: new Date((+new Date) + 120000)\n  ,\n    120000\n\n  Meteor.publish 'latest', (take = 50)->\n    check take, Number\n    Collections.files.collection.find {}\n    ,\n      limit: take\n      sort: 'meta.created_at': -1\n      fields:\n        _id: 1\n        name: 1\n        size: 1\n        meta: 1\n        isVideo: 1\n        isAudio: 1\n        isImage: 1\n        isText: 1\n        extension: 1\n\n  Meteor.publish 'file', (_id)->\n    check _id, String\n    Collections.files.collection.find _id\n\n  Meteor.methods\n    'filesLenght': -> Collections.files.collection.find({}).count()"]}